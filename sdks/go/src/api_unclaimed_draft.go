/*
Dropbox Sign API

Dropbox Sign v3 API

API version: 3.0.0
Contact: apisupport@hellosign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dropboxsign

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UnclaimedDraftApiService UnclaimedDraftApi service
type UnclaimedDraftApiService service

type UnclaimedDraftApiApiUnclaimedDraftCreateRequest struct {
	ctx _context.Context
	ApiService *UnclaimedDraftApiService
	unclaimedDraftCreateRequest *UnclaimedDraftCreateRequest
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateRequest) UnclaimedDraftCreateRequest(unclaimedDraftCreateRequest UnclaimedDraftCreateRequest) UnclaimedDraftApiApiUnclaimedDraftCreateRequest {
	r.unclaimedDraftCreateRequest = &unclaimedDraftCreateRequest
	return r
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateRequest) Execute() (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	return r.ApiService.UnclaimedDraftCreateExecute(r)
}

/*
UnclaimedDraftCreate Create Unclaimed Draft

Creates a new Draft that can be claimed using the claim URL. The first authenticated user to access the URL will claim the Draft and will be shown either the "Sign and send" or the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a 404.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UnclaimedDraftApiApiUnclaimedDraftCreateRequest
*/
func (a *UnclaimedDraftApiService) UnclaimedDraftCreate(ctx _context.Context) UnclaimedDraftApiApiUnclaimedDraftCreateRequest {
	return UnclaimedDraftApiApiUnclaimedDraftCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftApiService) UnclaimedDraftCreateExecute(r UnclaimedDraftApiApiUnclaimedDraftCreateRequest) (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftApiService.UnclaimedDraftCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unclaimedDraftCreateRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest struct {
	ctx _context.Context
	ApiService *UnclaimedDraftApiService
	unclaimedDraftCreateEmbeddedRequest *UnclaimedDraftCreateEmbeddedRequest
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest) UnclaimedDraftCreateEmbeddedRequest(unclaimedDraftCreateEmbeddedRequest UnclaimedDraftCreateEmbeddedRequest) UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest {
	r.unclaimedDraftCreateEmbeddedRequest = &unclaimedDraftCreateEmbeddedRequest
	return r
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest) Execute() (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	return r.ApiService.UnclaimedDraftCreateEmbeddedExecute(r)
}

/*
UnclaimedDraftCreateEmbedded Create Embedded Unclaimed Draft

Creates a new Draft that can be claimed and used in an embedded iFrame. The first authenticated user to access the URL will claim the Draft and will be shown the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a `404`. For this embedded endpoint the `requester_email_address` parameter is required.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest
*/
func (a *UnclaimedDraftApiService) UnclaimedDraftCreateEmbedded(ctx _context.Context) UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest {
	return UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftApiService) UnclaimedDraftCreateEmbeddedExecute(r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedRequest) (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftApiService.UnclaimedDraftCreateEmbedded")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create_embedded"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unclaimedDraftCreateEmbeddedRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateEmbeddedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateEmbeddedRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest struct {
	ctx _context.Context
	ApiService *UnclaimedDraftApiService
	unclaimedDraftCreateEmbeddedWithTemplateRequest *UnclaimedDraftCreateEmbeddedWithTemplateRequest
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) UnclaimedDraftCreateEmbeddedWithTemplateRequest(unclaimedDraftCreateEmbeddedWithTemplateRequest UnclaimedDraftCreateEmbeddedWithTemplateRequest) UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest {
	r.unclaimedDraftCreateEmbeddedWithTemplateRequest = &unclaimedDraftCreateEmbeddedWithTemplateRequest
	return r
}

func (r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) Execute() (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	return r.ApiService.UnclaimedDraftCreateEmbeddedWithTemplateExecute(r)
}

/*
UnclaimedDraftCreateEmbeddedWithTemplate Create Embedded Unclaimed Draft with Template

Creates a new Draft with a previously saved template(s) that can be claimed and used in an embedded iFrame. The first authenticated user to access the URL will claim the Draft and will be shown the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a `404`. For this embedded endpoint the `requester_email_address` parameter is required.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest
*/
func (a *UnclaimedDraftApiService) UnclaimedDraftCreateEmbeddedWithTemplate(ctx _context.Context) UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest {
	return UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftApiService) UnclaimedDraftCreateEmbeddedWithTemplateExecute(r UnclaimedDraftApiApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftApiService.UnclaimedDraftCreateEmbeddedWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create_embedded_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unclaimedDraftCreateEmbeddedWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateEmbeddedWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateEmbeddedWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest struct {
	ctx _context.Context
	ApiService *UnclaimedDraftApiService
	signatureRequestId string
	unclaimedDraftEditAndResendRequest *UnclaimedDraftEditAndResendRequest
}

func (r UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest) UnclaimedDraftEditAndResendRequest(unclaimedDraftEditAndResendRequest UnclaimedDraftEditAndResendRequest) UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest {
	r.unclaimedDraftEditAndResendRequest = &unclaimedDraftEditAndResendRequest
	return r
}

func (r UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest) Execute() (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	return r.ApiService.UnclaimedDraftEditAndResendExecute(r)
}

/*
UnclaimedDraftEditAndResend Edit and Resend Unclaimed Draft

Creates a new signature request from an embedded request that can be edited prior to being sent to the recipients. Parameter `test_mode` can be edited prior to request. Signers can be edited in embedded editor. Requester's email address will remain unchanged if `requester_email_address` parameter is not set.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The ID of the signature request to edit and resend.
 @return UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest
*/
func (a *UnclaimedDraftApiService) UnclaimedDraftEditAndResend(ctx _context.Context, signatureRequestId string) UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest {
	return UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftApiService) UnclaimedDraftEditAndResendExecute(r UnclaimedDraftApiApiUnclaimedDraftEditAndResendRequest) (UnclaimedDraftCreateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftApiService.UnclaimedDraftEditAndResend")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/edit_and_resend/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", _neturl.PathEscape(parameterToString(r.signatureRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unclaimedDraftEditAndResendRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftEditAndResendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftEditAndResendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
